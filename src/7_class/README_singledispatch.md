# Python における `functools.singledispatch` を選ぶ判断基準

## 目的
このドキュメントは、
**クラスのポリモーフィズムではなく `functools.singledispatch` を選ぶべきシチュエーション**を
設計判断の観点から整理したものです。

「使えるかどうか」ではなく
**「なぜそれを選ぶのか」**を明確にすることを目的とします。

---

## 結論（最重要）
**振る舞いの主体がオブジェクトではなく「処理」そのもののとき**、
クラス・ポリモーフィズムではなく `singledispatch` を選びます。

---

## 設計上の大きな分岐点

### クラス・ポリモーフィズムが向いている場合
- 振る舞いがデータ自身の責務
- オブジェクトが主語
- 状態を持つ
- メソッドが増えていく

```python
order.pay()
order.cancel()
order.refund()
```

→ ドメインモデル向き

---

### `singledispatch` が向いている場合
- 振る舞いは「データに対して行う操作」
- 主語は関数
- 状態を持たない
- 変換・解釈・正規化・検証が中心

```python
serialize(x)
normalize(x)
validate(x)
```

→ 境界層・ユーティリティ向き

---

## ポリモーフィズムを選ばず `singledispatch` を使いたくなるシチュエーション

### 1. built-in 型・外部ライブラリ型が対象
```python
serialize(str)
serialize(dict)
serialize(datetime)
```

- `str` や `dict` にメソッドは生やせない
- 継承も現実的でない

**型は触れないが、振る舞いは追加したい**
→ `singledispatch` が自然な選択

---

### 2. クラスを作るほどの概念ではない
- CLI 引数
- 設定ファイルの値
- 一時的な中間データ

クラス化すると：
- ファイル数が増える
- 学習コストが上がる
- 責務が不自然になる

**処理単位で閉じたい**
→ `singledispatch`

---

### 3. データ構造が混在する境界層
- API 入力
- JSON / dict / list / dataclass 混在
- pandas / numpy / 素の Python 型

この層で OOP をやると：
- 継承ツリーが歪む
- 境界なのにドメイン色が強くなる

**境界は関数で受け止める**
→ `singledispatch`

---

### 4. 将来、型が増えることが確定している
```python
@process.register
def _(x: NewType):
    ...
```

- 既存コードに手を入れない
- 呼び出し側は不変

**Open/Closed Principle を関数で満たせる**

---

### 5. 処理の切り口が変わる可能性がある
- 今は「型」で分岐
- 将来は「フォーマット」「入力経路」で分岐したくなるかもしれない

クラス設計を固めすぎると：
- 変更が破壊的になる

`singledispatch` は：
- 捨てやすい
- 差し替えやすい
- 試行錯誤フェーズに強い

---

## 逆に `singledispatch` を使わない方がいい場合

### 引数が複数で分岐したい
- `singledispatch` は第1引数のみ対応
- 複雑な条件分岐には不向き

---

### 分岐が小さく、増える見込みがない
```python
if isinstance(x, str):
    ...
else:
    ...
```
この程度なら素直な `if` の方が可読性が高い。

---

### 型ではなく「値」で分岐している
```python
if x == "admin":
    ...
```
これは別の設計問題。`singledispatch` は不適切。

---

## ビジネス・プロダクト視点での評価
`singledispatch` は
**将来の拡張コストを下げるための設計投資**。

- 今は 2 型、将来 5 型になる
- 呼び出し側を変えずに拡張したい
- バグ修正時の影響範囲を局所化したい

プロダクト寿命が長いコードほど効果が出る。

---

## 即断用チェックリスト

以下に YES が多ければ `singledispatch` を検討：

- データは自分のクラスではない
- 状態を持たない処理
- `if isinstance` が増えそう
- 将来、型が増える可能性が高い
- 境界層・変換層のコード
- クラスに責務を押し込みたくない

---

## まとめ（一言）
**オブジェクトに語らせるほどの物語がない処理**。
この場合、クラスのポリモーフィズムより
`functools.singledispatch` の方が設計として強い。
